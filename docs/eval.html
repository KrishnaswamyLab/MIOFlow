---

title: Eval


keywords: fastai
sidebar: home_sidebar

summary: "API details"
description: "API details"
nb_path: "10_eval.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 10_eval.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_points" class="doc_header"><code>generate_points</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L10" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_points</code>(<strong><code>model</code></strong>, <strong><code>df</code></strong>, <strong><code>n_points</code></strong>=<em><code>100</code></em>, <strong><code>sample_with_replacement</code></strong>=<em><code>False</code></em>, <strong><code>use_cuda</code></strong>=<em><code>False</code></em>, <strong><code>samples_key</code></strong>=<em><code>'samples'</code></em>, <strong><code>sample_time</code></strong>=<em><code>None</code></em>, <strong><code>autoencoder</code></strong>=<em><code>None</code></em>, <strong><code>recon</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>model (torch.nn.Module): Trained network with the property [`ode`](/MIOFlow/ode.html) corresponding to a `NeuralODE(ODEF())`.
    See `MIOFlow.ode` for more.
df (pd.DataFrame): DataFrame containing a column for the timepoint samples and the rest of the data.
n_points (int): Number of points to generate.
sample_with_replacement (bool): Defaults to `False`. Whether or not to use replacement when sampling
    initial timepoint.
use_cuda (bool): Defaults to `False`. Whether or not to use cuda.
samples_key (str): Defaults to `'samples'`. The column in the `df` which has the timepoint groups.
sample_time (list | None): Defaults to `None`. If `None` uses the group numbers in order as the
    timepoints as specified in the column `df[samples_key]`.
autoencoder (nn.Module|NoneType): Default to None, the trained autoencoder.
recon (bool): Default to 'False', whether to use the autoencoder for reconstruction.
</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>generated (float[float[]]): a list with shape `(len(sample_time), n_points, len(df.columns) - 1)`
    of the generated points.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_trajectories" class="doc_header"><code>generate_trajectories</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L53" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_trajectories</code>(<strong><code>model</code></strong>, <strong><code>df</code></strong>, <strong><code>n_trajectories</code></strong>=<em><code>30</code></em>, <strong><code>n_bins</code></strong>=<em><code>100</code></em>, <strong><code>sample_with_replacement</code></strong>=<em><code>False</code></em>, <strong><code>use_cuda</code></strong>=<em><code>False</code></em>, <strong><code>samples_key</code></strong>=<em><code>'samples'</code></em>, <strong><code>autoencoder</code></strong>=<em><code>None</code></em>, <strong><code>recon</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>model (torch.nn.Module): Trained network with the property [`ode`](/MIOFlow/ode.html) corresponding to a `NeuralODE(ODEF())`.
    See `MIOFlow.ode` for more.
df (pd.DataFrame): DataFrame containing a column for the timepoint samples and the rest of the data.
n_trajectories (int): Number of trajectories to generate.
n_bins (int): Number of bins to use for the trajectories. More makes it smoother. Defaults to `100`.
sample_with_replacement (bool): Defaults to `False`. Whether or not to use replacement when sampling
    initial timepoint.
use_cuda (bool): Defaults to `False`. Whether or not to use cuda.
samples_key (str): Defaults to `'samples'`. The column in the `df` which has the timepoint groups.
autoencoder (nn.Module|NoneType): Default to None, the trained autoencoder.
recon (bool): Default to 'False', whether to use the autoencoder for reconstruction.
</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>trajectories (float[float[]]): a list with shape `(n_bins, n_points, len(df.columns) - 1)`
    of the generated trajectories.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_plot_data" class="doc_header"><code>generate_plot_data</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L81" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_plot_data</code>(<strong><code>model</code></strong>, <strong><code>df</code></strong>, <strong><code>n_points</code></strong>, <strong><code>n_trajectories</code></strong>, <strong><code>n_bins</code></strong>, <strong><code>sample_with_replacement</code></strong>=<em><code>False</code></em>, <strong><code>use_cuda</code></strong>=<em><code>False</code></em>, <strong><code>samples_key</code></strong>=<em><code>'samples'</code></em>, <strong><code>logger</code></strong>=<em><code>None</code></em>, <strong><code>autoencoder</code></strong>=<em><code>None</code></em>, <strong><code>recon</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>model (torch.nn.Module): Trained network with the property [`ode`](/MIOFlow/ode.html) corresponding to a `NeuralODE(ODEF())`.
    See `MIOFlow.ode` for more.
df (pd.DataFrame): DataFrame containing a column for the timepoint samples and the rest of the data.
n_points (int): Number of points to generate.
n_trajectories (int): Number of trajectories to generate.
n_bins (int): Number of bins to use for the trajectories. More makes it smoother. Defaults to `100`.
sample_with_replacement (bool): Defaults to `False`. Whether or not to use replacement when sampling
    initial timepoint.
use_cuda (bool): Defaults to `False`. Whether or not to use cuda.
samples_key (str): Defaults to `'samples'`. The column in the `df` which has the timepoint groups.
autoencoder (nn.Module|NoneType): Default to None, the trained autoencoder.
recon (bool): Default to 'False', whether to use the autoencoder for reconstruction.
</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>points (float[float[]]): a list with shape `(len(df[sample_key].unique()), n_points, len(df.columns) - 1)`
    of the generated points.
trajectories (float[float[]]): a list with shape `(n_bins, n_points, len(df.columns) - 1)`
    of the generated trajectories.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_points_from_trajectories" class="doc_header"><code>get_points_from_trajectories</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L123" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_points_from_trajectories</code>(<strong><code>n_groups</code></strong>:<code>int</code>, <strong><code>trajectories</code></strong>:<code>Union</code>[<code>ndarray</code>, <code>list</code>], <strong><code>how</code></strong>:<code>Union</code>[<code>typing.Literal['start']</code>, <code>typing.Literal['middle']</code>, <code>typing.Literal['end']</code>]=<em><code>'start'</code></em>, <strong><code>logger</code></strong>:<code>Logger</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Arguments:
    n_groups (int): how many time points there are total.
    trajectories (np.ndarray | list): A list with three dimensions that correspond to:
        <code>(n_bins, n_points, n_dims)</code>, where <code>n_points</code> are the number of points / trajectories there are,
        <code>n_bins</code> correponds to how the trajectories were smoothed via binning (e.g. if there were 5 total
        time points one might have 100 bins to draw a smoother line when plotting), and <code>n_dims</code> are the
        number of dimensions the points are in (e.g. 2).
    how (str): Defaults to <code>'start'</code>. How to extract the point for the binned trajectories.
        If <code>'start'</code> takes the first point in the time window. If <code>'middle'</code> takes the floored averaged.
        If <code>'end'</code> takes the the last point in the time window.
    logger (logging.Logger): Defaults to <code>None</code>.
Returns:
    points (np.ndarray): Points at the corresponding indicices. If <code>trajectories</code> has shape:
        <code>(n_bins, n_points, n_dims)</code>, this will have shape <code>(n_groups, n_points, n_dims)</code>.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calculate_nn" class="doc_header"><code>calculate_nn</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L178" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calculate_nn</code>(<strong><code>df</code></strong>:<code>DataFrame</code>, <strong><code>generated</code></strong>:<code>Union</code>[<code>ndarray</code>, <code>list</code>]=<em><code>None</code></em>, <strong><code>trajectories</code></strong>:<code>Union</code>[<code>ndarray</code>, <code>list</code>]=<em><code>None</code></em>, <strong><code>compare_to</code></strong>:<code>Union</code>[<code>typing.Literal['time']</code>, <code>typing.Literal['any']</code>]=<em><code>'time'</code></em>, <strong><code>how</code></strong>:<code>Union</code>[<code>typing.Literal['start']</code>, <code>typing.Literal['middle']</code>, <code>typing.Literal['end']</code>]=<em><code>'start'</code></em>, <strong><code>k</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>groups</code></strong>:<code>Union</code>[<code>ndarray</code>, <code>list</code>]=<em><code>None</code></em>, <strong><code>sample_key</code></strong>:<code>str</code>=<em><code>'samples'</code></em>, <strong><code>method</code></strong>:<code>str</code>=<em><code>'mean'</code></em>, <strong><code>logger</code></strong>:<code>Logger</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Arguments:
    df (pd.DataFrame): DataFrame containing all points and time sample specified by <code>sample_key</code>
    generated (np.ndarray | list): A list of the generate points with shape
        <code>(n_groups, n_points, n_dims)</code>, where <code>n_groups</code> is the total number of time indicies
        as specified in <code>groups</code>.
    trajectories (np.ndarray | list): A list with three dimensions that correspond to:
        <code>(n_bins, n_points, n_dims)</code>, where <code>n_points</code> are the number of points / trajectories there are,
        <code>n_bins</code> correponds to how the trajectories were smoothed via binning (e.g. if there were 5 total
        time points one might have 100 bins to draw a smoother line when plotting), and <code>n_dims</code> are the
        number of dimensions the points are in (e.g. 2).
    compare_to (str): Defaults to <code>'time'</code>. Determines points to use for KNN. If <code>'time'</code> will only
        consider points at the same time index. If <code>'any'</code> will search for nearest points regardless
        of time.
    how (str): Defaults to <code>'start'</code>. How to extract the point for the binned trajectories.
        If <code>'start'</code> takes the first point in the time window. If <code>'middle'</code> takes the floored averaged.
        If <code>'end'</code> takes the the last point in the time window.
    k (int): Defaults to <code>1</code>. Number of points to compare predicted points in <code>generated</code>
        or <code>trajectories</code> to.
    groups (np.ndarray | list): Defaults to <code>None</code> and will be extracted from <code>df</code> is not provided.
        The sorted unique values of time samples from <code>df</code> as specified by <code>sample_key</code>.
    sample_key (str): Defaults to <code>'samples'</code>. The column in <code>df</code> which corresponds to the time index.
    method (str): Defaults to <code>'mean'</code>. If <code>'mean'</code> returns the mean of the knn distances. If <code>'quartile'</code>
        returns the mean of the worst (highest distances) quartile.
    logger (logging.Logger): Defaults to <code>None</code>.
Returns:
    mean_dist (float): mean distance of predicted points to the <code>n</code> nearest-neighbor points.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_tjnet_trajectories" class="doc_header"><code>generate_tjnet_trajectories</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L280" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_tjnet_trajectories</code>(<strong><code>model</code></strong>, <strong><code>df</code></strong>, <strong><code>n_bins</code></strong>=<em><code>10</code></em>, <strong><code>use_cuda</code></strong>=<em><code>False</code></em>, <strong><code>samples_key</code></strong>=<em><code>'samples'</code></em>, <strong><code>autoencoder</code></strong>=<em><code>None</code></em>, <strong><code>recon</code></strong>=<em><code>False</code></em>, <strong><code>where</code></strong>=<em><code>'end'</code></em>, <strong><code>start</code></strong>=<em><code>0</code></em>)</p>
</blockquote>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>model (nn.Module): Trained MIOFlow model.

df (pd.DataFrame): DataFrame of shape (n_cells, dimensions + 1), where the extra column
    stems from a samples column (column indicating the timepoint of the cell).
    By default the samples column is assumed to be `"samples"`.

n_bins (int): For each time point split it into `n_bins` for smoother trajectories.
    If there are `t` time points then there will be `t * n_bins` total points.

use_cuda (bool): Whether or not to use cuda for the model and autoencoder.

samples_key (str): The name of the column in the `df` that corresponds to the time
    samples. Defaults to `"samples"`.

autoencoder (nn.Module) Trained Geodesic Autoencoder.

recon (bool): Whether or not to use the `autoencoder` to reconstruct the output
    space from the `model`.

where (str): Choices are `"start"`, and `"end"`. Defaults to `"end"`. Whether or not
    to start the trajectories at `t_0` (`"start"`) or `t_n` (`"end"`).

start (int): Defaults to `0`. Where in [`generate_tjnet_trajectories`](/MIOFlow/eval.html#generate_tjnet_trajectories) the trajectories started.
    This is used if attempting to generate outside of `t0`. Note this works relative to `where`.
    E.g. if `where="end"` and `start=0` then this is the same as `groups[-1]`.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>trajectories (np.ndarray): Trajectories with shape (time, cells, dimensions)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_cell_indexes" class="doc_header"><code>get_cell_indexes</code><a href="https://github.com/dsm-72/MIOFlow/tree/main/MIOFlow/eval.py#L358" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_cell_indexes</code>(<strong><code>df</code></strong>, <strong><code>genes</code></strong>, <strong><code>trajectories</code></strong>, <strong><code>principal_components</code></strong>, <strong><code>top_n</code></strong>=<em><code>10</code></em>, <strong><code>where</code></strong>=<em><code>'end'</code></em>, <strong><code>start</code></strong>=<em><code>0</code></em>, <strong><code>palette</code></strong>=<em><code>'viridis'</code></em>, <strong><code>samples_key</code></strong>=<em><code>'samples'</code></em>, <strong><code>samples</code></strong>=<em><code>None</code></em>, <strong><code>cell_type_key</code></strong>=<em><code>None</code></em>, <strong><code>cell_types</code></strong>=<em><code>None</code></em>, <strong><code>use_cell_types</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<h2 id="Notes:">Notes:<a class="anchor-link" href="#Notes:"> </a></h2>
<pre><code>- `samples` refers to the timepoint sample e.g. `samples == 1` should be Boolean array
    corresponding to which rows in `df` that are of `t_1`.

- `use_cell_types` determines the output shape of `top_idxs`.

    + `use_cell_types=True`: `top_idxs` is a nested dictionary with structure
        ```
            {
                cell_type_0: {
                    gene_0: [id_0, id_1, ... id_n]
                },
                ...
                cell_type_m: {...},
            }
        ```
        Where each id is a cell of the outer cell type with the highest expression of
        the specified gene either at `t_0` (`where="start"`) or `t_n` (`where="end"`)
        e.g. cell_type_0[gene_0][0] is the id of the top cell of cell type `cell_type_0`
        expressing gene `gene_0`.

    + `use_cell_types=False`: `top_idxs` is a dictionary with structure
        ```
            {
                gene_0: [id_0, id_1, ... id_n],
                gene_1: [id_0, id_1, ... id_n],
                ...
                gene_m: [id_0, id_1, ... id_n],
            }
        ```
        Where each id is a cell (of any cell type) that has the highest expression of the
        specified gene either at `t_0` (`where="start"`) or `t_n` (`where="end"`).

</code></pre>
<h2 id="Arguments:">Arguments:<a class="anchor-link" href="#Arguments:"> </a></h2>
<pre><code>model (nn.Module): Trained MIOFlow model.

df (pd.DataFrame): DataFrame of shape (n_cells, n_genes), where the ordering of
    the columns `n_genes` corresponds to the columns of `principle_components`.
    It is assumed that the index of `df` are the cell types (but this need not be the case.
    See `cell_types`). If there are additional columns (e.g. `samples_key`, `cell_type_key`)
    should be after the gene columns.

genes (np.ndarray | list): Genes of interest to determine which cell indexes to find.

trajectories (np.ndarray): Trajectories with shape (time, cells, dimensions)

principal_components (np.ndarray): The principle components with shape (dimensions, n_genes).
    If used phate, can be obtained from `phate_operator.graph.data_pca.components_`

top_n (int): Defaults to `10`. The number of cells to use per condition. If
    `use_cell_types = False` this (conditions) will be the number of genes (`len(genes)`)
    otherwise it will be the number of cell types.

where (str): Choices are `"start"`, and `"end"`. Defaults to `"end"`. Whether or not
    the trajectories start at `t_0` (`"start"`) or `t_n` (`"end"`).

start (int): Defaults to `0`. Where in [`generate_tjnet_trajectories`](/MIOFlow/eval.html#generate_tjnet_trajectories) the trajectories started.
    This is used if attempting to generate outside of `t0`. Note this works relative to `where`.
    E.g. if `where="end"` and `start=0` then this is the same as `groups[-1]`.

palette (str): A Matplotlib colormap. Defaults to `"viridis"`.

samples_key (str): The name of the column in the `df` that corresponds to the time
    samples. Defaults to `"samples"`. If `df[samples_key]` throws a `KeyError`
    either because the `df` doesnt have this column in it or typo, will resort to
    `samples` to determine this.

samples (np.ndarray | list): List of timepoints where each value corresponds to the
    timepoint of the same row in `df`. Defaults to `None`.

cell_type_key (str): The column name in the provided DataFrame `df` the corresponds to the
    cell's cell types. Defaults to `None` which assumes the cell type is the index of the
    `df i.e. `df.index`

cell_types (np.ndarray | list): List of cell types to use from the provided DataFrame `df`.
    Defaults to `None`. If `use_cell_types = True` will attempt to figure this out from
    `cell_type_key`.

use_cell_types (bool): Whether or not to use cell types.

</code></pre>
<h2 id="Returns:">Returns:<a class="anchor-link" href="#Returns:"> </a></h2>
<pre><code>genes (np.ndarray): List of genes similar to those the user passed into this function except
    in order of the columns of the provided `df`. Any genes not found in the `df` put passed in
    by the user will be removed.

top_idxs (dict | dict[dict]): See notes. Dictionary or nested dictionary where leaf values are
    indicies of cells corresponding to those expressing the highest amount of specified genes.

inverse (np.nddary): Reconstructed gene space from `trajectories` and `principal_components`.
    It has the shape (n_time * n_bins, n_cells, n_genes). See `generate_tjnet_trajectories`.

colors (dict): Dictionary of either `{gene: color}` or `{cell_type: color}` depending on `use_cell_types`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>


